---
layout: post  
title: Objective-C Blocks Wiki  

---   
## Block 簡介  
  
Block 其實行為和 Function 很像,最大的差別是在可以存取同一個 Scope 的變數值。  
Block 實體會長成這樣 `^(傳入參數列) {行為主體};`  
Block 實體開頭是"^",接著是由小括號所包起來的參數列*(比如 int a, int b, float c),*  
行為的主體由大括號包起來,專有名詞叫做block literal。  
行為主體可以用`return`回傳值, *型別會被 compiler 自動辦識出來*。 
如果沒有參數列要這樣寫(void)。  
### 看個列子  
	^(int a) {return a*a;};  
這是代表 Block 會回傳輸入值的平方值(int a 就是參數列,return a\*a;就是行為主體)。   
**記得主體裡最後要加";"**   
**因為是敘述,而整個{}最後也要要加";"因為 Block 是個物件實體。**   
  
用法就是  
	int result = ^(int a) {return a*a;} (5);  
很怪吧。後面小括號裡的 5 會被當成 a 的輸入值然後經由 Block 輸出 5\*5 = 25 指定給 result 這個變數。   
  
有沒有簡單一點的方法不然每次都要寫這麼長?  
有.接下來要介紹一個叫Block Pointer的東西來簡化我們的寫法。  
**Block Pointer是這樣宣告的**   
  
	回傳值 (^名字) (參數列);  
**直接來看一個列子  **
	int (^square) (int);  // 有一個叫 square 的 Block Pointer,其所指向的 Block 是有一個 int 輸入和 int  
輸出  
	square = ^(int a ) {return a*a ;}; // 將剛剛 Block 實體指定給 square 使用Block Pointer的例子	int result = square(5); // 感覺上不就是 funtion 的用法嗎? 也可以把Block Pointer當成參數傳給一個function,比如說	void myFuction( int (^mySquare) (int) ); // function 的宣告, 傳入一個有一個 int 輸入和 int 輸出的 Block 型別的參數  
**呼叫這個 myFunction 的時候就是這樣呼叫  **
  
	int (^mySqaure) (int) = ^(int a) {return a*a;};  // 先給好一個有實體的 block pointer 叫 mySquare
	myFunction( mySqaure ); //把mySquare這個block pointer給myFunction這個function  
**或是不用 block pointer 直接給一個 block 實體,就這樣寫  **
	myFunction( ^(int a) {return a*a} ) ;  
**當成 Objective-C method 的傳入值的話都是要把型別寫在變數前面然後加上小括號,因些應該就要這樣寫 ** 

	-(void) objcMethod:( int (^) (int) ) square; // square 變數的型別是 int (^) (int)  
讀文至此是不是對 Block 有基本的認識?   
接下來我們要談談 Block 相關的行為和特色 首先是來看一下在 Block 裡面存取外部變數的方法  
### 存取變數1. 可以讀取和 Block pointer 同一個 scope 的變數值:  
	{	int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	int result = myPtr(3); // result is 11	}  
我們再來看一個很有趣的例子  
	{	int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	outA = 5; // 在呼叫 myPtr 之前改變 outA 的值	int result = myPtr(3); // **result 的值還是 11 並不是 8  ** 
	}  
**事實上呢,myPtr在其主體用到 outA 這個變數值的時候是做了一個 copy 的動作把 out A 的值 copy 下來。所以之後 outA 即使換了新的值對於 myPtr 裡 copy 的值是沒有影響到的。 **    

==> 要注意的是,這個指的值是變數的值,如果這個變數的值是一個記憶體的位置,換句話說, 這個變數是個 pointer 的話,它指到的值是可以在 block 裡被改變的。  
	{	NSMutableArray * mutableArray = [NSMutableArray arrayWithObjects:@"one",@"two",@"three",nil];	int result = ^(int a) { [mutableArray removeLastObject]; return a*a;} (5);	NSLog(@"test array %@", mutableArray);	}  

	原本 `mutableArray` 的值是`{@"one",@"two",@"three"}`在 `block` 裡被更改 `mutableArray` 所指向的物件後,`mutableArray` 的值就會被成`{@"one",@"two"}`  
2. 直接存取 static 的變數  
	{	static int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	outA = 5; // 在呼叫 myPtr 之前改變 outA 的值	int result = myPtr(3); // result 的值是 8,因為 outA 是個 static 變數會直接反應其值	}  
甚至可以在 block 裡面直接改變 outA 的值比如這樣寫  
	{	static int outA = 8;	int (^myPtr) (int) = ^(int a) { outA= 5; return outA+a;};	// block 裡面改變 outA 的值	int result = myPtr(3); // result 的值是 8,因為 outA 是個 static 變數會直接反應其值	}  
3. Block Variable  
在某個變數前面如果加上修飾字`__block` 的話(注意 block 前有兩個下底線),這個變數又 稱為block variable。那麼在`block`裡就可以任意修改此變數值,變數值的改變也可以知道。  
	{	__block int num = 5;	int (^myPtr) (int) = ^(int a) { return num++;};   
	int (^myPtr2) (int) = ^(int a) { return num++;};   
	int result = myPtr(0);	result = myPtr2(0);	}  
因為myPtr和myPtr2都有用到num這個block variable,最後result的值就會是7.  
  
### 生命周期和記憶體管理 
因為 block 也是繼承自 NSObject,所以其生命周期和記憶體的管理也就非常之重要。
**block 一開始都是被放到 stack 裡,換句話說其生命周期隨著 method 或 function 結束就 會被回收,和一般變數的生命周期一樣。**  
關於記憶體的管理請遵循這幾個要點  
1. block pointer的實體會在method或function結束後就會被清掉2. 如果要保存 block pointer 的實體要用-copy 指令,這樣 block pointer 就會被放到 heap 裡  
  
	2.1 block 主體裡用到的 block variable 也會被搬到 heap 而有新的記憶體位置,且 一並更新有用到這個 block variable 的 block 都指到新的位置  
  
	2.2 一般的 variable 值會被 copy  
  
	2.3 如果主體裡用到的 variable 是 object 的話,此 object 會被 retain, block release 時也會被 release  
  
	2.4 __block variable 裡用到的 object 是不會被 retain 的 首先來看一下這個例子  </br>
	  
		typedef int (^MyBlock)(int);		MyBlock genBlock();		int main(){		MyBlock outBlock = genBlock(); 
		int result = outBlock(5);		NSLog(@"result is %d",[outBlock retainCount] ); // segmentation faul t		NSLog(@"result is %d",result );		return 0 ; }		MyBlock genBlock() { int a = 3;		MyBlock inBlock = ^(int n) { return n*a;};		return inBlock ; }  
此程式由genBlock裡產生的block再指定給main function的outBlock變數,執行 這個程式會得到  
	Segmentation fault  

(註:有時候把 genBlock 裡的 a 去掉就可以跑出結果的情形,這是系統 cache 住記憶體, 並不是 inBlock 真得一直存在,久了還是會被回收,千萬不要以為是對的寫法) 表示我們用到了不該用的記憶體,在這個例子的情況下是在 genBlock 裡的 inBlock 變數 在 return 的時候就被回收了,outBlock 無法有一個合法的記憶體位置-retainCount 就 沒意義了。  
如果這個時候需要保留 inBlock 的值就要用-copy 指令,將 genBlock 改成  
	MyBlock genBlock() {   
	int a = 3;	MyBlock inBlock = ^(int n) { return n*a;	};	return [inBlock copy] ; }  
這樣[inBlock copy]的回傳值就會被放到heap,就可以一直使用(記得要release) 執行結果是  
	result is 1	result is 15  
*再次提醒要記得release outBlock。*  
如果一回傳[inBlock copy]的值就不再需要的時候可以這樣寫  
	MyBlock genBlock() { int a = 3;	MyBlock inBlock = ^(int n) { return n*a;	};	return [[inBlock copy] autorelease] ; }  
-copy 指令是為了要把 block 從 stack 搬到 heap,autorelease 是為了平衝 retainCou nt 加到 autorelease oop ,回傳之後等到事件結束就清掉。接下來是 block 存取到的 local variable 是個物件的型別,然後做 copy 指令時  
	MyBlock genBlock() 
	{ int a = 3;	NSMutableString * myString = [NSMutableString string]; MyBlock inBlock = ^(int n) {	NSLog(@"retain count of string %d",[myString retainCount]);	return n*a; };
	return [inBlock copy] ; }  
結果會印出  
	retain count of string 2   
  
這個結果和上面2.3提到的一樣,local variable被retain了   
  
那再來試試2.4,在local variable前面加上`__block`  
	MyBlock genBlock() { 
	int a = 3;	__block NSMutableString * myString = [NSMutableString string]; MyBlock inBlock = ^(int n) {	NSLog(@"retain count of string %d",[myString retainCount]);	return n*a; };	return [inBlock copy] ; }  
執行的結果就是會  
	retain count of string 1  
**Block Copying注意事項  **
如果在Class method裡面做copying block動作的話  
1. 在 Block 裡如果有直接存取到 `self`,則 `self` 會被 `retain`2. 在 Block 裡如果取存到 instance variable (無論直接或是從 accessor),則 `self` 會被 `retain`3. 取存到 local variable 所擁有的 object 時,這個 object 會被 `retain`**讓我們來看一個自訂的 Class**  
	@interface MyObject : NSObject { 
		NSString * title;	void (^myLog) (NSString * deco); 
		}
			-(void) logName; 
		@end
			@implementation MyObject	-(id) initWithTitle:(NSString * ) newTitle{	if(self = [super init]){ title = newTitle;
	myLog = [^(NSString * deco) {NSLog(@"%@%@%@",deco, titl e, deco );} copy];	}	return self; }
			-(void) logName{	myLog(@"=="); }
			-(void ) dealloc{	[myLog release]; [title release]; [super dealloc];	}
			@end  
在 main 裡使用如下  
	MyObject * mObj = [[MyObject alloc] initWithTitle:@"Car"]; NSLog(@"retainCount of MyObject is %d",[mObj retainCount] ); [mObj logName];  
其執行的結果為  
	retainCount of MyObject is 2  
==Car==  
因為在MyObject的建構子裡myLog這個block pointer用了title這個instance vari able然後就會retain self也就是MyObject的物件。盡量不要這樣寫,會造成retain cycle,改善的方法是把建構子改成這樣  
	-(id) initWithTitle:(NSString * ) newTitle{ if(self = [super init]){	title = newTitle;	myLog = [^(NSString * deco) {NSLog(@"%@%@%@",deco, ne	wTitle, deco );} copy]; }	return self; }  

在 Block 主體裡用 newTitle 這個變數而不是 title。這樣 self 就不會被 retain 了。 最後談一個小陷井  
	void (^myLog) (void);	BOOL result ;	if(result)	myLog = ^ {NSLog(@"YES");};	else	myLog = ^ {NSLog(@"NO");};	myLog();  
這樣很可能就會當掉了,因為 myLog 實體在 if 或是 else 結束後就被清掉了。要記得。 要用 `copy` 來解決這個問題,但要記得 `release`。
 