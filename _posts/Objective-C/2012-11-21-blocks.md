---
layout: post  
title: Objective-C Blocks Wiki  

--- 
     
## Blocks  
### What is a *block*?  
A block of code (i.e. a sequence of statements inside *{}*).  
Usually included "in-line"(内联) with the calling of method that is going to use the block of code.  
Very smart about local variables, referenced object, ect.  
  
### What does it look like?   
Here’s an example of calling a method that takes a block as an argument.    

	[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {	    NSLog(@“value for key %@ is %@”, key, value);	    if ([@“ENOUGH” isEqualToString:key]) {			*stop = YES; }	}];
  
This `NSLog()`s every `key` and `value` in `aDictionary` (but stops if the `key` is `ENOUGH`).  
It take only 1 argument which is *block*, the *block* takes 3 argument - `key`,`value` and a `Boolean`.  
它会遍历dictionary并把里面所有的key和value一组组展示，每组都会执行这个block,就是花括号之间的东西。  
  
### Can use local variables declared before the block inside the block  
  
	double stopValue = 53.5;	[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {	    NSLog(@“value for key %@ is %@”, key, value);	    if ([@“ENOUGH” isEqualToString:key] || ([value doubleValue] == stopValue)) {			*stop = YES; }	}];  
  
### But they are read only!  
  
	BOOL stoppedEarly = NO;	double stopValue = 53.5;	[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {	    NSLog(@“value for key %@ is %@”, key, value);	    if ([@“ENOUGH” isEqualToString:key] || ([value doubleValue] == stopValue)) {			*stop = YES;	        stoppedEarly = YES;  // ILLEGAL	} }];
  
### Unless you mark the local variable as `__block`  
  
	__block BOOL stoppedEarly = NO;	double stopValue = 53.5;	[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {	    NSLog(@“value for key %@ is %@”, key, value);	    if ([@“ENOUGH” isEqualToString:key] || ([value doubleValue] == stopValue)) {			￼*stop = YES;	        stoppedEarly = YES;  // this is legal now	    }	}];	if (stoppedEarly) NSLog(@“I stopped logging dictionary values early!”);


### Or if the “variable” is an instance variable
But we only access instance variables (e.g. _display) in setters and getters. So this is of minimal value to us.

### So what about objects which are messaged inside the block?  
  
	NSString *stopKey = [@“Enough” uppercaseString];	__block BOOL stoppedEarly = NO;	double stopValue = 53.5;	[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id value, BOOL *stop) {	    NSLog(@“value for key %@ is %@”, key, value);	    if ([stopKey isEqualToString:key] || ([value doubleValue] == stopValue)) {			￼*stop = YES;	        stoppedEarly = YES;  // this is legal now	    }	}];	if (stoppedEarly) NSLog(@“I stopped logging dictionary values early!”);  
  
`stopKey` will essentially have a `strong` pointer to it until the `block` goes out of scopeor the `block` itself leaves the heap (i.e. no one points `strong`ly to the `block` anymore).  
这里的key是在block里面被引用的，这个block 保持了strong pointer指向它们， 直到block不再运行。  
  
### Creating a “type” for a variable that can hold a block  
Blocks are kind of like “objects” with an unusual syntax for declaring variables that hold them. Usually if we are going to store a block in a variable, we typedef a type for that variable, e.g.,   
`typedef double (^unary_operation_t)(double op);`  //typedef double 说明返回double.  
 This declares a type called “`unary_operation_t`” for variables which can store a *block*.  //name of a type
(specifically, a *block* which takes a `double` as its only argument and returns a `double`)   
_t:这个带符号的type是我们自己定义的  
Then we could declare a variable, square, of this type and give it a value ...   
  
	unary_operation_t square;	square = ^(double operand) { // the value of the square variable is a block	    return operand * operand;	}  
And then use the variable `square` like this ...  
	`double squareOfFive = square(5.0); // squareOfFive would have the value 25.0 after this`     
  
(You don’t have to typedef, for example, the following is also a legal way to create square ...)   
	`double (^square)(double op) = ^(double op) { return op * op; };`      
  
*Hint: unary_operation_t 是一个类型，像NSString一样。 square是定义的变量。在square这个`block`中，有一个类型为`double`的变量`op`，返回的是 `op * op`*

### We don’t always typedef  
When a block is an argument to a method and is used immediately, often there is no typedef.   
Here is the declaration of the dictionary enumerating method we showed earlier ...   
 
	- (void)enumerateKeysAndObjectsUsingBlock:(void (^)(id key, id obj, BOOL *stop))block;  
   
*This (“block”) is the keyword for the argument (e.g. the local variable name for the argument inside the method implementation).*
  
No "name" for the type appears here.    
The syntax is exactly the same as the typedef except that the name of the typedef is not there.
For reference, here’s what a typedef for this argument would look like this ...  
`typedef void (^enumeratingBlock)(id key, id obj, BOOL *stop);`  
(i.e. the enumeratingBlock is not used in the method argument)	  

### Some shorthand allowed when defining a block  
(“Defining” means you are writing the code between the {}.)  
1. You do not have to declare the return type if it can be inferred from your code in the block.   
2. If there are no arguments to the block, you do not need to have any parentheses.Recall this code ...
	NSNumber *secret = [NSNumber numberWithDouble:42.0];	[brain addUnaryOperation:@“MoLtUaE” whichExecutesBlock:^(double operand) {	￼￼    return operand * [secret doubleValue];	}];

No return type. Inferred from the return inside.  
  
### Another example ...    

	[UIView animateWithDuration:5.0 animations:^{	    view.opacity = 0.5;	}];  
No arguments to this block. No need to say ^( ){…}    
  
## Block 簡介Block 其實行為和 Function 很像,最大的差別是在可以存取同一個 Scope 的變數值。  
Block 實體會長成這樣 `^(傳入參數列) {行為主體};`  
Block 實體開頭是"^",接著是由小括號所包起來的參數列*(比如 int a, int b, float c),*  
行為的主體由大括號包起來,專有名詞叫做block literal。  
行為主體可以用`return`回傳值, *型別會被 compiler 自動辦識出來*。 
如果沒有參數列要這樣寫(void)。  
### 看個列子  
	^(int a) {return a*a;};  
這是代表 Block 會回傳輸入值的平方值(int a 就是參數列,return a\*a;就是行為主體)。   
**記得主體裡最後要加";"**   
**因為是敘述,而整個{}最後也要要加";"因為 Block 是個物件實體。**   
  
用法就是  
	int result = ^(int a) {return a*a;} (5);  
很怪吧。後面小括號裡的 5 會被當成 a 的輸入值然後經由 Block 輸出 5\*5 = 25 指定給 result 這個變數。   
  
有沒有簡單一點的方法不然每次都要寫這麼長?  
有.接下來要介紹一個叫Block Pointer的東西來簡化我們的寫法。  
**Block Pointer是這樣宣告的**   
  
	回傳值 (^名字) (參數列);  
**直接來看一個列子  **
	int (^square) (int);  // 有一個叫 square 的 Block Pointer,其所指向的 Block 是有一個 int 輸入和 int  
輸出  
	square = ^(int a ) {return a*a ;}; // 將剛剛 Block 實體指定給 square 使用Block Pointer的例子	int result = square(5); // 感覺上不就是 funtion 的用法嗎? 也可以把Block Pointer當成參數傳給一個function,比如說	void myFuction( int (^mySquare) (int) ); // function 的宣告, 傳入一個有一個 int 輸入和 int 輸出的 Block 型別的參數  
**呼叫這個 myFunction 的時候就是這樣呼叫  **
  
	int (^mySqaure) (int) = ^(int a) {return a*a;};  // 先給好一個有實體的 block pointer 叫 mySquare
	myFunction( mySqaure ); //把mySquare這個block pointer給myFunction這個function  
**或是不用 block pointer 直接給一個 block 實體,就這樣寫  **
	myFunction( ^(int a) {return a*a} ) ;  
**當成 Objective-C method 的傳入值的話都是要把型別寫在變數前面然後加上小括號,因些應該就要這樣寫 ** 

	-(void) objcMethod:( int (^) (int) ) square; // square 變數的型別是 int (^) (int)  
讀文至此是不是對 Block 有基本的認識?   
接下來我們要談談 Block 相關的行為和特色 首先是來看一下在 Block 裡面存取外部變數的方法  
### 存取變數1. 可以讀取和 Block pointer 同一個 scope 的變數值:  
	{	int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	int result = myPtr(3); // result is 11	}  
我們再來看一個很有趣的例子  
	{	int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	outA = 5; // 在呼叫 myPtr 之前改變 outA 的值	int result = myPtr(3); // **result 的值還是 11 並不是 8  ** 
	}  
**事實上呢,myPtr在其主體用到 outA 這個變數值的時候是做了一個 copy 的動作把 out A 的值 copy 下來。所以之後 outA 即使換了新的值對於 myPtr 裡 copy 的值是沒有影響到的。 **    

==> 要注意的是,這個指的值是變數的值,如果這個變數的值是一個記憶體的位置,換句話說, 這個變數是個 pointer 的話,它指到的值是可以在 block 裡被改變的。  
	{	NSMutableArray * mutableArray = [NSMutableArray arrayWithObjects:@"one",@"two",@"three",nil];	int result = ^(int a) { [mutableArray removeLastObject]; return a*a;} (5);	NSLog(@"test array %@", mutableArray);	}  

	原本 `mutableArray` 的值是`{@"one",@"two",@"three"}`在 `block` 裡被更改 `mutableArray` 所指向的物件後,`mutableArray` 的值就會被成`{@"one",@"two"}`  
2. 直接存取 static 的變數  
	{	static int outA = 8;	int (^myPtr) (int) = ^(int a) {return outA+a;}; // block 裡面可以讀同一個 scope 的 outA 的值	outA = 5; // 在呼叫 myPtr 之前改變 outA 的值	int result = myPtr(3); // result 的值是 8,因為 outA 是個 static 變數會直接反應其值	}  
甚至可以在 block 裡面直接改變 outA 的值比如這樣寫  
	{	static int outA = 8;	int (^myPtr) (int) = ^(int a) { outA= 5; return outA+a;};	// block 裡面改變 outA 的值	int result = myPtr(3); // result 的值是 8,因為 outA 是個 static 變數會直接反應其值	}  
3. Block Variable  
在某個變數前面如果加上修飾字`__block` 的話(注意 block 前有兩個下底線),這個變數又 稱為block variable。那麼在`block`裡就可以任意修改此變數值,變數值的改變也可以知道。  
	{	__block int num = 5;	int (^myPtr) (int) = ^(int a) { return num++;};   
	int (^myPtr2) (int) = ^(int a) { return num++;};   
	int result = myPtr(0);	result = myPtr2(0);	}  
因為myPtr和myPtr2都有用到num這個block variable,最後result的值就會是7.  
  
### 生命周期和記憶體管理 
因為 block 也是繼承自 NSObject,所以其生命周期和記憶體的管理也就非常之重要。
**block 一開始都是被放到 stack 裡,換句話說其生命周期隨著 method 或 function 結束就 會被回收,和一般變數的生命周期一樣。**  
關於記憶體的管理請遵循這幾個要點  
1. block pointer的實體會在method或function結束後就會被清掉2. 如果要保存 block pointer 的實體要用-copy 指令,這樣 block pointer 就會被放到 heap 裡  
  
	2.1 block 主體裡用到的 block variable 也會被搬到 heap 而有新的記憶體位置,且 一並更新有用到這個 block variable 的 block 都指到新的位置  
  
	2.2 一般的 variable 值會被 copy  
  
	2.3 如果主體裡用到的 variable 是 object 的話,此 object 會被 retain, block release 時也會被 release  
  
	2.4 __block variable 裡用到的 object 是不會被 retain 的 首先來看一下這個例子  </br>
	  
		typedef int (^MyBlock)(int);		MyBlock genBlock();		int main(){		MyBlock outBlock = genBlock(); 
		int result = outBlock(5);		NSLog(@"result is %d",[outBlock retainCount] ); // segmentation faul t		NSLog(@"result is %d",result );		return 0 ; }		MyBlock genBlock() { int a = 3;		MyBlock inBlock = ^(int n) { return n*a;};		return inBlock ; }  
此程式由genBlock裡產生的block再指定給main function的outBlock變數,執行 這個程式會得到  
	Segmentation fault  

(註:有時候把 genBlock 裡的 a 去掉就可以跑出結果的情形,這是系統 cache 住記憶體, 並不是 inBlock 真得一直存在,久了還是會被回收,千萬不要以為是對的寫法) 表示我們用到了不該用的記憶體,在這個例子的情況下是在 genBlock 裡的 inBlock 變數 在 return 的時候就被回收了,outBlock 無法有一個合法的記憶體位置-retainCount 就 沒意義了。  
如果這個時候需要保留 inBlock 的值就要用-copy 指令,將 genBlock 改成  
	MyBlock genBlock() {   
	int a = 3;	MyBlock inBlock = ^(int n) { return n*a;	};	return [inBlock copy] ; }  
這樣[inBlock copy]的回傳值就會被放到heap,就可以一直使用(記得要release) 執行結果是  
	result is 1	result is 15  
*再次提醒要記得release outBlock。*  
如果一回傳[inBlock copy]的值就不再需要的時候可以這樣寫  
	MyBlock genBlock() { int a = 3;	MyBlock inBlock = ^(int n) { return n*a;	};	return [[inBlock copy] autorelease] ; }  
-copy 指令是為了要把 block 從 stack 搬到 heap,autorelease 是為了平衝 retainCou nt 加到 autorelease oop ,回傳之後等到事件結束就清掉。接下來是 block 存取到的 local variable 是個物件的型別,然後做 copy 指令時  
	MyBlock genBlock() 
	{ int a = 3;	NSMutableString * myString = [NSMutableString string]; MyBlock inBlock = ^(int n) {	NSLog(@"retain count of string %d",[myString retainCount]);	return n*a; };
	return [inBlock copy] ; }  
結果會印出  
	retain count of string 2   
  
這個結果和上面2.3提到的一樣,local variable被retain了   
  
那再來試試2.4,在local variable前面加上`__block`  
	MyBlock genBlock() { 
	int a = 3;	__block NSMutableString * myString = [NSMutableString string]; MyBlock inBlock = ^(int n) {	NSLog(@"retain count of string %d",[myString retainCount]);	return n*a; };	return [inBlock copy] ; }  
執行的結果就是會  
	retain count of string 1  
**Block Copying注意事項  **
如果在Class method裡面做copying block動作的話  
1. 在 Block 裡如果有直接存取到 `self`,則 `self` 會被 `retain`2. 在 Block 裡如果取存到 instance variable (無論直接或是從 accessor),則 `self` 會被 `retain`3. 取存到 local variable 所擁有的 object 時,這個 object 會被 `retain`**讓我們來看一個自訂的 Class**  
	@interface MyObject : NSObject { 
		NSString * title;	void (^myLog) (NSString * deco); 
		}
			-(void) logName; 
		@end
			@implementation MyObject	-(id) initWithTitle:(NSString * ) newTitle{	if(self = [super init]){ title = newTitle;
	myLog = [^(NSString * deco) {NSLog(@"%@%@%@",deco, titl e, deco );} copy];	}	return self; }
			-(void) logName{	myLog(@"=="); }
			-(void ) dealloc{	[myLog release]; [title release]; [super dealloc];	}
			@end  
在 main 裡使用如下  
	MyObject * mObj = [[MyObject alloc] initWithTitle:@"Car"]; NSLog(@"retainCount of MyObject is %d",[mObj retainCount] ); [mObj logName];  
其執行的結果為  
	retainCount of MyObject is 2  
==Car==  
因為在MyObject的建構子裡myLog這個block pointer用了title這個instance vari able然後就會retain self也就是MyObject的物件。盡量不要這樣寫,會造成retain cycle,改善的方法是把建構子改成這樣  
	-(id) initWithTitle:(NSString * ) newTitle{ if(self = [super init]){	title = newTitle;	myLog = [^(NSString * deco) {NSLog(@"%@%@%@",deco, ne	wTitle, deco );} copy]; }	return self; }  

在 Block 主體裡用 newTitle 這個變數而不是 title。這樣 self 就不會被 retain 了。 最後談一個小陷井  
	void (^myLog) (void);	BOOL result ;	if(result)	myLog = ^ {NSLog(@"YES");};	else	myLog = ^ {NSLog(@"NO");};	myLog();  
這樣很可能就會當掉了,因為 myLog 實體在 if 或是 else 結束後就被清掉了。要記得。 要用 `copy` 來解決這個問題,但要記得 `release`。
 