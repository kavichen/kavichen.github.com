<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>指针学习</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1 id="toc_1">指针</h1>
<h2 id="toc_1.1">预备知识</h2>
<h3 id="toc_1.1.1">地址的概念</h3>
<ul>
<li>
为了访问内存中的某个储存单元，我们要为它编号，这种编号成为内存地址。通过地址，我们就能够访问该地址所标识的储存单元。

</ul>
<h3 id="toc_1.1.2">变量的地址</h3>
<ul>
<li>
变量在内存中总占用几个连续的字节，开始字节的地址，就是变量的地址。

</ul>
<hr />
<h2 id="toc_1.2">指针及相关概念</h2>
<h3 id="toc_1.2.1">指针</h3>
<ul>
<li>
一个变量的地址称为该变量的指针

</ul>
<h3 id="toc_1.2.2">指针变量</h3>
<ul>
<li>
若一个变量专用于存放另一个变量的地址（指针），则该变量称为指针变量。

</ul>
<h3 id="toc_1.2.3">指针的对象</h3>
<ul>
<li>
当把变量的地址放入指针变量后，我们就可以说这个指针指向了该变量。

</ul>
<h4 id="toc_1.2.3.1">变量的存取方法</h4>
<ol>
<li>
直接存取 - 直接根据变量名存取数据，例如：i = 3;

<li>
间接存取 - 通过指针变量存取相应变量的数据，例如：<code>*i_pointer = 20;</code>

</ol>
<hr />
<h2 id="toc_1.3">变量的指针和指向变量的指针变量</h2>
<h3 id="toc_1.3.1">指针变量的定义</h3>
<ul>
<li>
一般形式：[存储类型] 类型标示符 <code>*</code>变量名

<li>
例如：<code>static char *name;</code>

<li>
[存储类型] 是指针变量的存储类型

<li>
<code>*</code> - 表示定义指针变量，不是<code>*</code>运算符

<li>
指针变量的类型：指明了该指针指向的内存空间所储存的数据类型。

</ul>
<h4 id="toc_1.3.1.1">定义指针变量时的问题</h4>
<ol>
<li>
例如：在<code>int *ptr1,ptr2</code>中，<code>ptr2</code>被定义为整形变量，而非整型指针变量。

<li>
定义中的<code>*</code>表示所定义的变量是指针变量，但指针变量名是ptr1,ptr2，而非<code>*ptr1</code>,<code>*ptr2</code>

<li>
指针变量只能指向定义时嗦规定类型的变量，这个规定的类型称为该指针变量的“基类型”。

<li>
【重要】定义指针变量后，并未确定该变量指向何处。也就是说该变量的值不确定。在引用指针变量前必须首先让它指向一个变量。

</ol>
<h3 id="toc_1.3.2">指针变量的初始化</h3>
<ol>
<li>
一般形式：[存储类型]数据类型 *指针名 = 初始地址值

<li>
例如：
<pre>
  int i;
  int *p = &amp;i;
  int *q = p; // 先给指针变量p赋值，然后将p赋值给q
</pre>

<li>
指针变量必须先赋值，再使用

<ul>
<li>
不正确例子
<pre>
      main()
      {
        int i = 10;
        int *p;
        *p = i; //p并没有赋值，而使用间接赋值，i的值会储存在一个随机的地址上【危险】
      }
</pre>

<li>
正确例子：
<pre>
      main()
      {
        int i = 10,k;
        int *p;
        p = &amp;k;
        *p = i;
      }
</pre>

</ul>
</ol>
<h3 id="toc_1.3.3">零指针与空类型指</h3>
<h4 id="toc_1.3.3.1">零指针</h4>
<ul>
<li>
定义：指针变量值为0

<li>
表示：<code>int *p = 0</code>

<ul>
<li>
p指向地址为0的单元，系统保证该单元不作它用，表示指针变量值没有意义
<pre>
      #define NULL 0
      int *p = NULL;
</pre>

</ul>
<li>
<code>p = NULL</code> 与未对p赋值不同

<li>
用途：

<ul>
<li>
避免指针变量的非法引用

<li>
在程序中常作为状态比较

</ul>
</ul>
<h4 id="toc_1.3.3.2">void *类型指针</h4>
<ul>
<li>
表示：<code>void *p;</code>

<ul>
<li>
表示不指定p是指向哪一种类型数据的指针变量

</ul>
<li>
使用时要进行强制类型转换

</ul>
<h3 id="toc_1.3.4">指针变量的运算</h3>
<h4 id="toc_1.3.4.1"><code>&amp;</code>与<code>*</code>运算符</h4>
<ul>
<li>
两者关系：互为逆运算

<li>
<code>i_pointer = &amp;i = &amp;(* i_pointer)</code>

<li>
<code>i = *i_pointer = *(&amp;i)</code>

<li>
<code>i_pointer</code> - 指针变量，它的内容是地址量

<li>
<code>*i_pointer</code> - 指针的目标变量，它的内容是数据

<li>
<code>&amp;i_pointer</code> - 指针变量占用内存的地址

</ul>
<h4 id="toc_1.3.4.2">指针的赋值运算（=）</h4>
<ul>
<li>
就是把地址赋值给指针变量。

<li>
指针的赋值运算可以是以下三种方式：

<ol>
<li>
使用取地址运算符，把地址赋值给指针变量，如<code>int i,*pi; pi = &amp;i</code>

<li>
把指针变量的赋值给另一个指针变量，如<code>int i, *pa, *pb; pa = &amp;i; pb = pa;</code>

<li>
把指针变量赋值给符号常量<code>NULL</code>，如<code>int *pi; pi = NULL;</code>

<ul>
<li>
说明:<code>NULL</code>是一个空指针，表示改指针变量的值没有意义。作用是为了避免对没有被初始化的指针变量的非法引用。<code>NULL</code>的定义在<code>stdio.h</code>中

<li>
在定义指针变量时，可以立即将一个地址值赋给指针变量，这就是指针变量的初始化。指针变量的初始化也是指针的赋值运算。

<li>
指针变量间的赋值和引用应保证基本类型相同

</ul>
</ol>
</ul>
<h4 id="toc_1.3.4.3">移动指针的运算</h4>
<h5 id="toc_1.3.4.3.1">指针的加减运算</h5>
<ul>
<li>
指针的加减运算（+，-）

<li>
指针的自加自减运算(++,--,+=,=-)

<li>
指针与整型值加减的结果是指针，表示使该指针指向其下移或上移存储单元个数（整型值）之后的内存地址。存储单元的大小就是该指针的数据类型所需的内存大小

<li>
指针与指针的加运算毫无意义，所说指针与指针没有加运算

<li>
指针与指针的减运算要求相减的两个指针属于同一类型，其结果是整数，表示两个指针之间的数据个数。其结果值的计算公式是：ptr1 - ptr2 = (ptr1的值 - ptr2的值)/指针的数据类型所占的字节数

</ul>
<h5 id="toc_1.3.4.3.2">指针的++,--,+=,-=运算</h5>
<ul>
<li>
++，+=：是移动指针到下一个或下几个储存单元

<li>
--，-=：是移动指针到上一个或上几个储存单元

<li>
注意：*ptr++ 和 （*ptr）++的区别

</ul>
<h4 id="toc_1.3.4.4">指针变量作为函数参数</h4>
<ul>
<li>
指针可以用作函数参数，这在条用函数希望改变参数的值时非常有用。

<ul>
<li>
例如：用指针变量编写实现两个数的交换函数
<pre>
      void swap(int *p1, int *p2)
      {
        int temp;
        temp = *p1;
        *p1 = *p2;
        *p2 = temp;
      }
      main()
      {
        int x1=100, x2=200;
        printf("x1=%d,x2=%d\n",x1,x2);
        swap(&amp;x1,&amp;x2);
        printf("x1=%d, x2=%d\n",x1,x2);
      }
</pre>

</ul>
<li>
如果函数的参数不调用指针而用整数，则不能实现交换，如下：
<pre>
      void swap(int a, int b)
      {
        int temp;
        temp = a; // 这里只是调换了形参a与b的值，并未对x1和x2的值进行调换
        a = b;
        b = temp;
      }
      main()
      {
        int x1 = 100, x2 = 200;
        prinf("x1=%d,x2=%d\n",x1,x2);
        swap(x1,x2);
        printf("x1=%d, x2=%d\n",x1,x2);
      }
</pre>

<li>
通过函数调用得到n个要改变的值的方法

<ol>
<li>
在主调函数中设n个变量，用n个指针变量指向它们

<li>
将指针变量作实参，将这n个变量的地址传给所调用的函数的形参

<li>
通过形参指针变量，改变该n个变量的值

<li>
主调函数中就可以使用这些改变了值的变量

</ol>
<li>
【重要】需要改变某地址上的值，而不是改变形参的值

</ul>
<hr />
<h2 id="toc_1.4">数组的指针和指向数组的指针变量</h2>
<h3 id="toc_1.4.1">概念</h3>
<ul>
<li>
数组的指针 - 是数组的起始值

<li>
数组元素的指针 - 是数组元素的地址，当指针变量指向数组或数组元素时，它就是指向数组的指针变量

<li>
C规定：

<ol>
<li>
数组名代表数组的首地址（起始地址），也就是第一个元素的地址

<li>
当指针变量p指向数组时，p+1指向数组的下一个元素。假设一个整形元素站两个字节，p+1是使p的地址加2个字节。

<ul>
<li>
如<code>int a[10], *p;</code>，则<code>p=a;</code>与<code>p=&amp;a[0];</code>等价，称指针变量p指向数组元素<code>a[0]</code>

<li>
<code>p+i</code>,<code>a+i</code>,<code>&amp;a[i]</code>都是<code>a[i]</code>的地址

</ul>
</ol>
</ul>
<h3 id="toc_1.4.2">数组元素的引用</h3>
<ol>
<li>
用下标法引用数组元素，如：<code>a[3]=45; b[2][5]=200;</code>

<li>
用指针法引用数组元

<ul>
<li>
假如：<code>int a[10], *p, i; p=a;</code>

<li>
则：

<ol>
<li>
<code>*(p+i) *(a+i)</code>则代表元素<code>a[i]</code>

<li>
<code>*(p+i)</code>也可以写成<code>p[i]</code>

<li>
<code>*(p+i) *(a+i) a[i] p[i]</code>等价，都代表数组a的第i+1个元素

</ol>
</ul>
</ol>
<h4 id="toc_1.4.2.1">说明</h4>
<ol>
<li>
指针变量与数组名的区别 - 指针变量是地址变量，数组名是地址常量。e.g 指针变量的内容可以在程序运行过过程中被改变；而数组名一旦被定义，它的值就不能被改变了

<ul>
<li>
例如：<code>int i, *p, a[6];</code>,则<code>p = &amp;i;</code>可行

<li>
<code>a = &amp;i</code>,<code>a++</code>,<code>a+=i</code> 不可行

</ul>
<li>
利用指针变量编程时特别要注意指针变量的当前值

</ol>
<h3 id="toc_1.4.3">数组名做函数的参数</h3>
<ul>
<li>
实际上，能够接受并存放值的只能是指针变量。因此，C编译系统都是将形参数组作为指针变量来处理的。

<ul>
<li>
<code>f(int arr[],int n)</code>等价于<code>f(int *arr, int n)</code>

<li>
使用形参数组的概念只是为了与实参数组对应，直观，便于理解而已。

</ul>
</ul>
<h3 id="toc_1.4.4">一级指针变量与一维数组的关系</h3>
<ul>
<li>
<code>int *p</code> 与 <code>int q[10]</code>

<li>
数组名是指针（地址）常量

<li>
<code>p=q;p+i</code>是<code>q[i]</code>的地址

<li>
数组元素的表示方法：下标法和指针法，即若p=q，则p[i]=q[i]=<strong>(p+i)=</strong>(q+i)

<li>
形参数组实质上是指针变量，即int q[] = int *q

<li>
在定义指针变量（不是形参）时，不能把<code>int *p</code>写成<code>int p[]</code>

<li>
系统只给p分配能保存一个指针值的内存区（一般2字节）而给q分配2*10字节的内存区

</ul>
<hr />
<h2 id="toc_1.5">二维数组的指针</h2>
<h3 id="toc_1.5.1">二维数组的指针概念</h3>
<ul>
<li>
对于一维数组：

<ol>
<li>
数组名array表示数组的首地址，即array[0]的地址

<li>
数组名array是地址常量

<li>
array+i是元素array[i]的地址

<li>
array[i] = *(array+i)

</ol>
<li>
对二维数组 <code>int a[3][4]</code>

<ul>
<li>
a:二维数组的首地址，即第0行的首地址

<li>
a+i:第i行的首地址

<li>
a[i] = <code>*(a+i)</code>:第i行第0列的元素地址

<li>
a[i]+j = <code>*(a+i)+j</code>:第i行第j列的元素地址

<li>
<code>*(a[i]+j)</code> = <code>*(*(a+i)+j)</code> = <code>a[i][j]</code>

</ul>
<li>
<code>a+i</code>=<code>&amp;a[i]</code>=<code>a[i]</code>=<code>*(a+i)</code>=<code>&amp;a[i][0]</code>,值相等，含义不同

<ul>
<li>
<code>a+i</code>=<code>&amp;a[i]</code>,表示第i行首地址，指向行

<li>
<code>a[i]</code>=<code>*(a+i)</code>=<code>&amp;a[i][0]</code>,表示第i行第0列元素地址，指向列

</ul>
</ul>
<h4 id="toc_1.5.1.1">指向一维数组的指针变量</h4>
<ul>
<li>
定义形式：数据类型(*指针名)[一维数组维数]

<li>
例如: <code>int (*p)[4];</code>

<li>
可让p指向二维数组的某一行，例如: 
<pre>
  int a[3][4];
  (*p)[4]=a[0];
</pre>

<li>
维数指针变量的维数必须和二维数组的列数相同

</ul>
<h4 id="toc_1.5.1.2">二维数组的指针作函数参数</h4>
<ul>
<li>
用指向变量的指针变量

<li>
用指向一维数组的指针变量

<li>
用二维数组名
<pre>
#include &lt;stdio.h&gt;
void average(float *p, int n)
{
float *p_end, sum = 0, aver;
p_end  = p+n-1;
for(;p&lt;=p_end;p++) 
  sum = sum + (*p);
aver = sum/n;
printf("average=%5.2f\n",aver);
}

void search(float (*p)[4],int n)
{
  int i;
  printf("No.%d :\n",n);
  for(i=0;i&lt;4;i++)
  {
    printf("%5.2f ",*(*(p+n)+i));
  }
}
int main()
{
 void average(float *p, int n);
 void search(float (*p)[4],int n);
 float score[3][4] = {{65,67,79,60},{80,87,90,81},{90,99,100,98}};
 average(*score,12);
 search(score,1);
 return (0);
}
</pre>

</ul>
<h4 id="toc_1.5.1.3">二维数组与一维数组指针变量的关系</h4>
<ul>
<li>
例如: <code>int a[5][10]</code> 与 <code>int(*p)[10]</code>

<li>
二维数组名是一个指向有10个元素的一维数组的~指针常量~

<li>
<code>p=a+i</code>使p指向二维数组的第i行

<li>
<code>*(*(p+i)+j)</code> = <code>a[i][j]</code>

<li>
二维数组的形参是一维数组指针变量，即 <code>int x[][10]</code> 与 <code>int (*x)[10]</code>

<li>
变量定义（不是形参) 时，两者不等价

<li>
系统只给<code>p</code>分配能保存一个指针值的内存区（一般2字节）；而给<code>a</code>分配2*5*10字节的内存区

</ul>
<hr />
<h1 id="toc_2">字符串指针和指向字符串的指针变量</h1>
<ul>
<li>
字符串指针：字符串的首地址

<li>
字符指针变量：指向字符串的指针变量

<li>
字符指针变量定义的一般形式：<code>char *指针变量名</code>

<li>
字符指针变量定义时可以赋初始值

<li>
例如:<code>char *strp = "Hello!";</code>

<ul>
<li>
定义了一个指向字符串的指针变量，并将字符串的首地址赋值给strp指针变量，即：使指针变量strp指向字符串首地址

</ul>
</ul>
<h2 id="toc_2.1">C程序访问字符串的方法</h2>
<ol>
<li>
用字符数组存放一个字符串

<ul>
<li>
例如:<code>char s[] = "I am a student.";</code>

<li>
<code>printf("%s\n,s");</code>

<li>
<code>for(i=0;s[i];i++) printf("%c",s[i]);</code>

</ul>
<li>
用字符指针指向一个字符串

<ul>
<li>
例如：<code>char *ps = "I am a student.";</code>

<li>
<code>printf("%s\n",ps);</code>

<li>
<code>for(;*ps;ps++) printf("%c",*ps);</code>

</ul>
<li>
字符数组和字符指针变量都可以在定义时赋初始值，但以下方法对字符数组非法，对字符串合法:
  <code>char s[10]; s = "hello!"</code> 非法
  <code>char *ps; ps = "hello!"</code> 合法

<li>
字符数组名是指针常量，只能表示一个确定的字符串，不能改变。而字符指针变量的值是可以改变的，它可以代表不同的字符串。

<li>
若定义了一个指针变量，并使它指向一个字符串，就可以用下标形式引用指针变量所指字符串中的字符，例如：
  <code>char *a = "Kavi";</code> 
  <code>printf("%c",a[2]);</code>

<li>
用指针变量指向一个格式字符串，可以用它代替printf函数的格式字符串
  <code>int a; char *format; format = "a=%d\n";</code>
  <code>printf(format,a);</code>相当于<code>printf("a=%d\n",a);</code>

</ol>
<h2 id="toc_2.2">字符指针变量与字符数组</h2>
<h3 id="toc_2.2.1"><code>char *cp</code>与<code>char str[20]</code></h3>
<ul>
<li>
str由若干元素组成，每个元素放一个字符；而cp终存放字符串首地址

<li>
<code>char str[20];</code> <code>str = "kavi";</code> 非法，因为<code>str</code>是地址常量

<li>
<code>char *cp;</code> <code>cp = "kavi";</code> 合法，因为<code>cp</code>是地址变量

<li>
<code>cp</code>接收键入字符串时，必须先开辟存储空间，例如：
<pre>
    char *cp,str[10];
    cp = str;
    scanf("%s",cp);
</pre>

</ul>
<hr />
<h1 id="toc_3">指针函数和函数指针</h1>
<h2 id="toc_3.1">指针函数</h2>
<ul>
<li>
返回指针的函数称作指针函数

<li>
指针函数定义函数首部的一般形式: 类型名 *函数名（参数表）

<li>
含义：函数的返回值是一个指针，它指向所定义类型的数据

<li>
例如：<code>int *a(int x,int y); /* 函数原型声明 */</code> 含义：a是函数名，调用它以后能得到一个指向整型数据的指针（地址）

</ul>
<h2 id="toc_3.2">函数的指针及指向函数的指针变量</h2>
<ul>
<li>
函数的指针（地址）概念：每一个函数都占用一段内存，在编译时，被分配一个入口地址，这个入口地址就称为函数的指针

<li>
指向函数的指针变量

<ul>
<li>
定义指向函数的指针变量的一般形式：类型标识符 (*指针变量名)();

<li>
例如：<code>float (*p)();</code>

<li>
含义：定义了<code>p</code>是指向函数的指针变量，函数的返回值就是float类型

</ul>
<li>
注意：

<ol>
<li>
<code>(*p)()</code>表示定义一个指向函数的指针变量，它并不是固定指向哪个函数

<li>
对指向函数的指针变量,<code>p+n</code>,<code>p++</code>,<code>p--</code>等运算是无意义的

<li>
注意区别<code>int (*p)()</code>和<code>int *p()</code>

</ol>
</ul>
<h2 id="toc_3.3">对指向函数的指针变量赋值</h2>
<ul>
<li>
对指向函数的指针变量赋值 - 将一个函数的函数名（代表入口地址）赋值给指向函数的指针变量，也称该指针变量指向了这个函数。

<li>
例如：
<pre>
  int max(int x,int y);
  int (*p)();
  p = max;
</pre>

<ul>
<li>
注意：赋值时，只需要给出函数名而不必给出参数。

</ul>
</ul>
<h2 id="toc_3.4">函数的调用</h2>
<ol>
<li>
通过函数名调用函数

<li>
通过指向函数的指针调用函数

<li>
当指向函数的指针函数<code>p</code>指向某一函数时（即指针变量<code>p</code>被赋值），调用函数的形式为

<ul>
<li>
<code>(*p)(实参1, 实参2, ....)</code>

<li>
例如：若有定义
<pre>
        int max(int x, int y);
        int (*p)(),a,b,c;
        p = max;
</pre>

<li>
则有语句
<pre>
     c = (*p)(a,b);
</pre>

</ul>
</ol>
<hr />
<h1 id="toc_4">指针数组和指向指针的指针</h1>
<ul>
<li>
指针数组：就是数组中每个元素是基类型相同指针变量

<li>
指针数组用于处理二维数组或多个字符串

<li>
定义指针数组的一般形式：[存储类型]类型标示符 *指针变量名[常量表达式];

<li>
例子：<code>int *p[2];</code>

<li>
<code>p</code>是一个一维数组，每个元素都是一个指向整型变量的指针变量。可以将整型变量的地址赋值给<code>p[0]</code>或<code>p[1]</code>

<li>
注意：区别<code>int *p[2]</code>与<code>int (*p)[2]</code>的含义

<ul>
<li>
<code>int *p[2]</code>表示数组指针

<li>
<code>int (*p)[2]</code>表示一维数组指针变量

</ul>
</ul>
<h2 id="toc_4.1">指针数组的应用</h2>
<ul>
<li>
指针数组赋值与初始化

<li>
赋值
<pre>
  main()
  {
    int b[2][3];
    int *pb[2];
    pb[0] = b[0];
    pb[1] = b[1];
  }
</pre>

<li>
初始化
<pre>
  main()
  {
    int b[2][3], *pb = {b[0],b[1]};
  }
</pre>

</ul>
<h2 id="toc_4.2">二维数组与指针数组的区别</h2>
<ul>
<li>
<code>char name[5][9] = {"gain","much","strong","point","bye"};</code>

<li>
<code>char *name[5] = {"gain","much","strong","point","bye"};</code>

<li>
二维数组储存空间固定，字符指针数组相当于可变列长的二维数组

<li>
分配内存单元 = 数组长度 * 2 + 各字符串长度

<li>
指针数组元素的作用相当于二维数组的行名，但指针数组中元素是指针变量，二维数组的行名是地址常量

</ul>
<h3 id="toc_4.2.1">用指针数组指向动态内存</h3>
<ul>
<li>
<code>void</code>类型

<li>
例子：
<pre>
    char *p1;
    int a = 2;
    void *p2;
    p2 = &amp;a;
    p1 = (char*)p2;
</pre>

<li>
可以将一个函数定义为<code>void</code>指针类型。表示该函数返回的是一个地址，它指向空类型，如需要引用此地址，也需要根据情况进行类型转换,如:
<pre>
    void *malloc(unsigned size);
</pre>

<li>
功能:分配size字节的储存区

<li>
函数调用例子：<code>char *p; p = (char *)malloc(60);</code>,分配60字节的存储区，并返回该内存区的地址，赋值给<code>p</code>

</ul>
<h3 id="toc_4.2.2">指针数组做<code>main</code>函数的形参</h3>
<ul>
<li>
<code>main</code>函数是由系统调用的，可以有参数

<li>
<code>main</code>函数实参：实参是和命令一起给出的，也就是在DOS提示符下，输入本程序的可执行文件名和需要传给main函数的参数，命令行的一般形式为：

<ul>
<li>
可执行文件名 参数1 参数2 ... 参数n

<li>
带参数的<code>main</code>函数的原型是：<code>main(int argc, char *argv[]);</code>

<ul>
<li>
<code>argc</code> 命令行参数（包括可执行文件名的数目n+1）

<li>
<code>argv</code>指针数组，各元素分别指向命令行中的各参数(包括可执行文件名),即字符串的首地址

</ul>
</ul>
</ul>

<h3 id="toc_4.2.3">指向指针的指针变量</h3>
<ul>
<li>
指向指针的指针变量（也称多级指针）只能存放指针变量的地址

<li>
一级指针：指针变量中存放目标变量的地址

<ul>
<li>
例：
<pre>
      int *p;
      int i = 3;
      p = &amp;i;
      *p = 5;
</pre>

</ul>
<li>
二级指针：指针变量中存放一级指针变量的地址

<ul>
<li>
定义形式：类型标示符 **指针变量名;

<li>
例如：
<pre>
     int **q, *p, i = 5;
     p = &amp;i;
     q = &amp;p;
</pre>

<li>
含义:使指针变量<code>p</code>指向<code>i</code>，指针变量<code>q</code>指向<code>p</code>

<li>
注意：要是用一个多级指针指向目标值，必须连续使用指针运算符“*”，上例中<code>**q</code>就是<code>i</code>的值

</ul>
<li>
例子：
<pre>
    int i, **p;
    p = &amp;i;(X)
</pre>

<ul>
<li>
<code>p</code>是二级指针，不能用变量地址为其赋值

</ul>
</ul>
<hr />
<hr />
<h1 id="toc_5">指针的数据类型小结</h1>
<ul>
<li>
<code>int *p</code>

<ul>
<li>
<code>p</code>为指向整型数据的指针变量

</ul>
<li>
<code>int *p[n]</code>

<ul>
<li>
定义指针数据<code>p</code>，它有n个指向整型数据的指针元素

</ul>
<li>
<code>int (*p)[n]</code>

<ul>
<li>
<code>p</code>为指向含n个元素的一维数组的指针变量

</ul>
<li>
<code>int *p()</code>

<ul>
<li>
<code>p</code>为带回一个指针的函数，该指针指向整型数据

</ul>
<li>
<code>int (*p)()</code>

<ul>
<li>
<code>p</code>为指向函数的指针，该函数返回一个整型值

</ul>
<li>
<code>int **p</code>

<ul>
<li>
<code>p</code>是一个指针变量，它指向一个指向整数数据的指针变量

</ul>
</ul>

</body>
</html>
