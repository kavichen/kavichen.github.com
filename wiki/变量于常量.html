<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>变量与常量[转]</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1 id="toc_1">变量与常量</h1>
<h2 id="toc_1.1">常量</h2>
<ul>
<li>
其值不会发生改变的量，称为常量。

</ul>
<h3 id="toc_1.1.1">常量分类</h3>
<ul>
<li>
直接常量：又称字面常量，如12，0，4.6，'a',"abcd"

<li>
符号常量：#define PI 3.14

</ul>
<h3 id="toc_1.1.2">常量的特点</h3>
<ul>
<li>
常量的值在作用域内不会发生改变，也不能被赋值。

<li>
其在出现时就被当作一个立即数来使用。

<li>
一旦申明了一个常量，那么常量所在的内存就被加上了只读属性

</ul>
<h2 id="toc_1.2">变量</h2>
<ul>
<li>
其值在其作用域内可以改变的量称为变量。一个变量应该有一个名字，在内存中占据一定的存储空间。变量使用前必须要被定义，每个变量都有自己的地址。

</ul>
<h3 id="toc_1.2.1">变量分类</h3>
<ul>
<li>
变量依据其定义的类型，分为不同类型，如：整型变量，字符型变量，浮点型变量，指针型变量。

</ul>
<h3 id="toc_1.2.2">变量的特点</h3>
<ul>
<li>
变量可以发生改变

<li>
每个变量必须要有一个名字和它所在内存空间绑定。

</ul>
<h3 id="toc_1.2.3">变量名和变量的值</h3>
<h4 id="toc_1.2.3.1">变量名</h4>
<ul>
<li>
变量名在变量申明的时候，该名字就和内存中一块地址绑定在一起了。

<li>
可以通过变量名直接找到对应的内存地址

<li>
也可以通过地址找到其内存区域

</ul>
<h4 id="toc_1.2.3.2">变量的值</h4>
<ul>
<li>
变量的值是变量所对应的内存区域内存放的二进制序列

<li>
变量的值不会因为变量的类型发生了改变而改变

<li>
当变量被转换成为对应类型时，内存区域的二进制序列以该类型的形式翻译出来（这也是强制类型转换能够成立的原因）

<li>
例如：
<pre>
   int a = 97; //整形变量a在内存中是以97的二进制形式存放的，当使用它时，会被以十进制形式表现出来
   char ch1 = 'a'; //字符变量ch1的ASCII码是97，也是以97的二进制存放的，使用时，会被以字符'a'的形式表现出来
   char ch2 = (char)a; //将整型变量a强制类型转换成字符型，a变量里的值没有变，变的是它的类型，它里面的值还是97的二进制，它类型变成了char，97的二进制变成char型，表现出来就是字符’a’
   char *p = (char*)a; //声明一个字符型指针变量p，p是个变量，它里面的值可变，它的值是整型变量a的值强制类型转换成了字符指针类型。这个时候p里的值还是97的二进制，只不过这个97的意义已经代表了一个字符型指针，也就是一个指向字符的地址了
</pre>

<li>
由此可见：变量在内存中存放和它的值没有关系，而是和它的类型相关的。同样我们也可以得出：一个二进制序列对于计算机本身而言没有任何意义，计算机根本不知道这个二进制数据是干什么的，只有具体到它的类型时或出现在合适的场合时，才能代表具体的意义。如果一串二进制数据出现在地址总线上，它代表是一个地址，如果该相同数据出现在数据总线上，它代表是一个数据。所以，当我们看到一个数据时，比如：3.1415926，不能把它戴上定向思维的帽子认为它就是PI，而是要看清它的本质，它就是一堆二进制代码。

</ul>
<hr />
<h1 id="toc_2">例子</h1>
<h2 id="toc_2.1">例子1</h2>
<pre>
  char ch = ‘a’;
  int a = (int)ch;
  printf(“%d %c\n”, a, ch);
</pre>
<ul>
<li>
ch是什么？ch里装的是什么？a是什么？a里面装的是什么？打印什么？

<li>
测试对变量类型的理解和类型转换。ch是字符型变量，ch里是字符’a’的二进制数，a是整型变量，a里面是字符’a’的二进制数的整型表示方式，以十进制数表示出来97。打印结果为97 和 a。

</ul>
<h2 id="toc_2.2">例子2</h2>
<pre>
  int add = 0x12345678;
  int *p = (int*)add
</pre>
<ul>
<li>
add是什么？add里装的是什么？p是什么？p里装的是什么？*p又是什么？&amp;p又是什么？

<li>
测试对整型和地址类型转换。add是一个整数变量，add里是0x12345678的二进制数，以十进制表现出来，p是一个整型指针变量名，p里面是0x12345678的二进制数，以地址的方式表现出来，代表地址0x12345678。*p是通过*去访问地址0x12345678这个地址处的数据（如果你试图去打印它，会出错，因为这个地址你不一定有权限去访问）。&amp;p是取出整型指针变量p的地址，因为p是一个变量，它也有自己的地址，所以可以取出它的地址来（见上面变量的定义）。

</ul>
<h2 id="toc_2.3">例子3</h2>
<pre>
  #define PI 3.14
  int a = PI;
  printf(“%d\n”, a);
</pre>
<ul>
<li>
上面的代码有没有问题？

<li>
宏定义一个常量PI，PI这个符号代表了3.14，在代码执行前的预处理阶段第二行int a = PI，已经被替换为了int a = 3.14，将3.14赋值给整型，会舍弃掉小数点后面部分结果，仅保留整数部分，打印结果为3。

</ul>
<h2 id="toc_2.4">例子4</h2>
<pre>
  #define PI 3.14
  printf(“%d\n”, PI); 
</pre>
<ul>
<li>
代码有没有问题？

<li>
和上面3一样，在预处理阶段被替换成了printf(“%d\n”, 3.14)，结果为1374389535，这是因为将浮点型的3.14在内存中的数据，以整型来表现的。

</ul>
<h2 id="toc_2.5">例子5</h2>
<pre>
  #define PI 3.14
  int a = PI;
  PI = 3.1415926;
  int b = PI;
  printf(“%d %d\n”, a, b);
</pre>
<ul>
<li>
代码有没有问题?

<li>
第三行PI = 3.1415926会出错，PI是个常量其被替换成了3.14 = 3.1415926，3.14是个字面常量，不能被赋值。错误信息为“向无效左值赋值出错”（关于常见错误信息，见C语言常见错误详解章节）。

</ul>
<h2 id="toc_2.6">例子6</h2>
<pre>
  char *str = “hello world”;
  printf(“%s\n”, str);
  *str = “goodbye world”;
  printf(“%s\n”, str);
</pre>
<ul>
<li>
代码有没有问题?

<li>
第三行*str = “goodbye world”出错，第一行中将字符串常量“hello world”的首地址给了字符指针变量str，第三行试图将“goodbye world”的首地址，通过*str的访问方式覆盖str指向的字符串常量“hello world”。这句话理解起来都比较费劲，因为这里有两个错误：

<ol>
<li>
试图向常量里写数据。- “hello world” 是字符串常量，那么这个字符串空间里的内容不能改变。

<li>
指针变量里应该放地址，字符串都是以首地址为地址。 - 向一个地址里写入字符串应该使用strcpy。*str只是代表了str指向的字符串中的第一个字符，将字符串地址写入到一个字符里肯定不行。

</ol>
</ul>

</body>
</html>
