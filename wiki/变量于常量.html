<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>变量与常量</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1 id="toc_1">变量与常量</h1>
<h2 id="toc_1.1">常量</h2>
<ul>
<li>
其值不会发生改变的量，称为常量。

</ul>
<h3 id="toc_1.1.1">常量分类</h3>
<ul>
<li>
直接常量：又称字面常量，如12，0，4.6，'a',"abcd"

<li>
符号常量：#define PI 3.14

</ul>
<h3 id="toc_1.1.2">常量的特点</h3>
<ul>
<li>
常量的值在作用域内不会发生改变，也不能被赋值。

<li>
其在出现时就被当作一个立即数来使用。

<li>
一旦申明了一个常量，那么常量所在的内存就被加上了只读属性

</ul>
<h2 id="toc_1.2">变量</h2>
<ul>
<li>
其值在其作用域内可以改变的量称为变量。一个变量应该有一个名字，在内存中占据一定的存储空间。变量使用前必须要被定义，每个变量都有自己的地址。

</ul>
<h3 id="toc_1.2.1">变量分类</h3>
<ul>
<li>
变量依据其定义的类型，分为不同类型，如：整型变量，字符型变量，浮点型变量，指针型变量。

</ul>
<h3 id="toc_1.2.2">变量的特点</h3>
<ul>
<li>
变量可以发生改变

<li>
每个变量必须要有一个名字和它所在内存空间绑定。

</ul>
<h3 id="toc_1.2.3">变量名和变量的值</h3>
<h4 id="toc_1.2.3.1">变量名</h4>
<ul>
<li>
变量名在变量申明的时候，该名字就和内存中一块地址绑定在一起了。

<li>
可以通过变量名直接找到对应的内存地址

<li>
也可以通过地址找到其内存区域

</ul>
<h4 id="toc_1.2.3.2">变量的值</h4>
<ul>
<li>
变量的值是变量所对应的内存区域内存放的二进制序列

<li>
变量的值不会因为变量的类型发生了改变而改变

<li>
当变量被转换成为对应类型时，内存区域的二进制序列以该类型的形式翻译出来（这也是强制类型转换能够成立的原因）

<li>
例如：
<pre>
   int a = 97; //整形变量a在内存中是以97的二进制形式存放的，当使用它时，会被以十进制形式表现出来
   char ch1 = 'a'; //字符变量ch1的ASCII码是97，也是以97的二进制存放的，使用时，会被以字符'a'的形式表现出来
   char ch2 = (char)a; //将整型变量a强制类型转换成字符型，a变量里的值没有变，变的是它的类型，它里面的值还是97的二进制，它类型变成了char，97的二进制变成char型，表现出来就是字符’a’
   char *p = (char*)a; //声明一个字符型指针变量p，p是个变量，它里面的值可变，它的值是整型变量a的值强制类型转换成了字符指针类型。这个时候p里的值还是97的二进制，只不过这个97的意义已经代表了一个字符型指针，也就是一个指向字符的地址了
</pre>

<li>
由此可见：变量在内存中存放和它的值没有关系，而是和它的类型相关的。同样我们也可以得出：一个二进制序列对于计算机本身而言没有任何意义，计算机根本不知道这个二进制数据是干什么的，只有具体到它的类型时或出现在合适的场合时，才能代表具体的意义。如果一串二进制数据出现在地址总线上，它代表是一个地址，如果该相同数据出现在数据总线上，它代表是一个数据。所以，当我们看到一个数据时，比如：3.1415926，不能把它戴上定向思维的帽子认为它就是PI，而是要看清它的本质，它就是一堆二进制代码。

</ul>
<hr />

</body>
</html>
